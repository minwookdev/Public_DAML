using System;
using System.Collections.Generic;
using System.Linq;
using CoffeeCat;
using CoffeeCat.Utils;
using Sirenix.OdinInspector;
using UnityEngine;
using UnityEngine.Serialization;

namespace RandomDungeonWithBluePrint
{
    [CreateAssetMenu(menuName = "CoffeeCat/Scriptable Object/FieldBluePrint")]
    public class FieldBluePrint : ScriptableObject
    {
        [Serializable]
        public class Section
        {
            [SerializeField] private int index = default;
            [SerializeField] private bool roomIndispensable = default;
            [SerializeField] private int makeRoomWeight = default;
            [SerializeField] private RectInt rect = default;
            [SerializeField] private Vector2Int minRoomSize = default;

            public int Index => index;
            public bool RoomIndispensable => roomIndispensable;
            public int MakeRoomWeight => makeRoomWeight;
            public RectInt Rect => rect;
            public Vector2Int MinRoomSize => minRoomSize;
            public int Width => rect.width;
            public int Height => rect.height;

            public int AdjoiningWithDirection(Section other)
            {
                return rect.AdjoiningWithDirection(other.Rect);
            }

            public Vector2Int GetEdge(Section other, Vector2Int initial = default)
            {
                return rect.GetEdge(AdjoiningWithDirection(other), initial);
            }
        }

        [Serializable]
        public class Connection
        {
            [SerializeField] private int fromIndex = default;
            [SerializeField] private int toIndex = default;

            public int From => fromIndex;
            public int To => toIndex;
        }

        [SerializeField, Header("맵 타입")] private string mapType = default;
        [SerializeField, Header("전체 크기")] private Vector2Int size = default;
        [SerializeField, Header("방 개수 변동폭")] private int minRoomNum = default;
        [SerializeField] private int maxRoomNum = default;
        [SerializeField, Header("랜덤 길 생성 수 변동폭")] private int minRandomBranchNum = default;
        [SerializeField] private int maxRandomBranchNum = default;
        [SerializeField, Header("초기 커넥션 자동생성 여부")] private bool autoGenerateDefaultConnections = default;
        [SerializeField, Header("구획")] private List<Section> sections = default;
        [SerializeField] private List<Connection> connections = default;
        
        // 로그라이트 룸 정의
        [PropertySpace(10f), Title("RogueLite Room Configuration", bold: true)]
        [ShowInInspector, ReadOnly] public int MinEntrance { get; private set; } = 1;
        [ShowInInspector, ReadOnly] public int MinExtrance { get; private set; } = 1;
        
        [HorizontalGroup("Split", LabelWidth = 40, Order = 20f)]
        [BoxGroup("Split/Reward Room", Order = -1f)] // Reward Room Range
        [LabelText("Min")] public int MinRewardRoomCount = 1;
        [BoxGroup("Split/Reward Room")] 
        [LabelText("Max")] public int MaxRewardRoomCount = 1;
        [BoxGroup("Split/Shop Room", Order = 0f)]   // Shop Room Range
        [LabelText("Min")] public int MinShopRoomCount = 1;
        [BoxGroup("Split/Shop Room")]
        [LabelText("Max")] public int MaxShopRoomCount = 1;
        [BoxGroup("Split/Battle Room", Order = 1f)] // Battle Room Range and Options
        [LabelText("Min")] public int MinBattleRoomCount = 0;
        [BoxGroup("Split/Battle Room")]
        [LabelText("Max")] public int MaxBattleRoomCount = 1;
        
        [HorizontalGroup("Battle Room Data"), PropertyOrder(20f)]
        [SerializeField] private BattleRoomDataEntity[] battleRoomEntities = null;
        [HorizontalGroup("Battle Room Data"), PropertyOrder(20f)]
        [SerializeField] private int[] battleRoomEntitiesWeights = default;
        
        [InfoBox("This Options is Experimental", InfoMessageType.Warning)]
        [TitleGroup("Connection Extensions"), PropertyOrder(30f)] public bool IsConnectAllCompletely;
        [TitleGroup("Connection Extensions"), PropertyOrder(30f)] public bool IsRemoveInvalidConnects;

        public string MapType => mapType;
        public Vector2Int Size => size;
        public int MinRoomNum => minRoomNum;
        public int MaxRoomNum => maxRoomNum;
        public int MinRandomBranchNum => minRandomBranchNum;
        public int MaxRandomBranchNum => maxRandomBranchNum;
        public bool AutoGenerateDefaultConnections => autoGenerateDefaultConnections;
        public List<Section> Sections => sections.ToList();
        public List<Connection> Connections => connections.ToList();
        public int RequireMinimumRoomCounts {
            get => MinEntrance + MinExtrance + MinRewardRoomCount + MinShopRoomCount + MinBattleRoomCount;
        }
        public RoomDataEntity GetRoomEntityByWeight(RoomType roomType) {
            return roomType switch {
                RoomType.MonsterSpawnRoom => GetBattleRoomEntityByWeight(),
                //_                         => null,
                //RoomType.PlayerSpawnRoom  => null,
                //RoomType.ShopRoom         => null,
                //RoomType.BossRoom         => null,
                //RoomType.RewardRoom       => null,
                //RoomType.EmptyRoom        => null,
                //RoomType.ExitRoom         => null,
                _ => null,
            };
            
            #region INNER
            
            BattleRoomDataEntity GetBattleRoomEntityByWeight() {
                if (battleRoomEntities == null || battleRoomEntities.Length <= 0) {
                    return null;
                }

                if (battleRoomEntities.Length == 1) {
                    return battleRoomEntities[0];
                }

                return battleRoomEntities[GetIndexByWeight(battleRoomEntitiesWeights)];
            }
            
            int GetIndexByWeight(int[] weights) {
                float total = 0f;
                for (int i = 0; i < weights.Length; i++) {
                    total += weights[i];
                }

                float randomPoint = total * UnityEngine.Random.value;
                for (int i = 0; i < weights.Length; i++) {
                    if (randomPoint < weights[i]) {
                        return i;
                    }
                    else {
                        randomPoint -= weights[i];
                    }
                }

                return weights.Length - 1;
            }
            
            #endregion
        }
    }
}
